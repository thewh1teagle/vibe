use eyre::{bail, Context, ContextCompat, Result};
use futures_util::StreamExt;
use reqwest::multipart;
use serde::Deserialize;
use std::io::BufRead;
use std::path::Path;
use std::process::{Child, Command, Stdio};
use tokio_util::io::ReaderStream;

pub struct SonaProcess {
    port: u16,
    child: Child,
    client: reqwest::Client,
}

#[derive(Debug, Deserialize)]
struct ReadySignal {
    #[allow(dead_code)]
    status: String,
    port: u16,
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type")]
#[serde(rename_all = "snake_case")]
#[allow(dead_code)]
pub enum SonaEvent {
    Progress { progress: i32 },
    Segment { start: f64, end: f64, text: String, speaker: Option<i32> },
    Result { text: String },
    Error { message: String },
}

impl SonaProcess {
    pub fn spawn(binary_path: &Path, ffmpeg_path: Option<&Path>, diarize_path: Option<&Path>) -> Result<Self> {
        tracing::debug!("spawning sona at {}", binary_path.display());

        let mut cmd = Command::new(binary_path);
        cmd.args(["serve", "--port", "0"])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        if let Some(ffmpeg) = ffmpeg_path {
            tracing::debug!("setting SONA_FFMPEG_PATH={}", ffmpeg.display());
            cmd.env("SONA_FFMPEG_PATH", ffmpeg);
        }

        if let Some(diarize) = diarize_path {
            tracing::debug!("setting SONA_DIARIZE_PATH={}", diarize.display());
            cmd.env("SONA_DIARIZE_PATH", diarize);
        }

        #[cfg(target_os = "windows")]
        {
            use std::os::windows::process::CommandExt;
            cmd.creation_flags(0x08000000); // CREATE_NO_WINDOW
        }

        let mut child = cmd.spawn().context("failed to spawn sona binary")?;

        let mut stderr = child.stderr.take();
        let stdout = child.stdout.take().context("failed to get sona stdout")?;
        let mut reader = std::io::BufReader::new(stdout);
        let mut line = String::new();

        let mut read_stderr = || -> String {
            let Some(s) = stderr.take() else { return String::new() };
            let mut buf = String::new();
            let mut r = std::io::BufReader::new(s);
            // Read first line of stderr for diagnostics
            let _ = r.read_line(&mut buf);
            buf.truncate(4096);
            buf
        };

        if let Err(e) = reader.read_line(&mut line) {
            let stderr_output = read_stderr();
            if stderr_output.is_empty() {
                return Err(e).context("failed to read sona ready signal");
            }
            bail!("failed to read sona ready signal: {}\n\nsona stderr: {}", e, stderr_output.trim());
        }

        let signal: ReadySignal = match serde_json::from_str(line.trim()) {
            Ok(s) => s,
            Err(e) => {
                let stderr_output = read_stderr();
                if stderr_output.is_empty() {
                    bail!("failed to parse sona ready signal: {}", e);
                }
                bail!("failed to parse sona ready signal: {}\n\nsona stderr: {}", e, stderr_output.trim());
            }
        };

        tracing::debug!("sona ready on port {}", signal.port);

        // Spawn threads to consume remaining stdout/stderr so the pipes don't block
        std::thread::spawn(move || {
            let mut buf = String::new();
            while reader.read_line(&mut buf).unwrap_or(0) > 0 {
                tracing::trace!("sona stdout: {}", buf.trim());
                buf.clear();
            }
        });
        if let Some(stderr) = stderr {
            std::thread::spawn(move || {
                let mut reader = std::io::BufReader::new(stderr);
                let mut buf = String::new();
                while reader.read_line(&mut buf).unwrap_or(0) > 0 {
                    tracing::debug!("sona stderr: {}", buf.trim());
                    buf.clear();
                }
            });
        }

        Ok(Self {
            port: signal.port,
            child,
            client: reqwest::Client::new(),
        })
    }

    pub fn base_url(&self) -> String {
        format!("http://127.0.0.1:{}", self.port)
    }

    pub async fn load_model(&self, path: &str) -> Result<()> {
        let url = format!("{}/v1/models/load", self.base_url());
        let mut last_err = None;
        for attempt in 0..3 {
            if attempt > 0 {
                tracing::debug!("retrying load_model (attempt {})", attempt + 1);
                tokio::time::sleep(std::time::Duration::from_millis(500 * (1 << attempt))).await;
            }
            match self
                .client
                .post(&url)
                .json(&serde_json::json!({"path": path}))
                .send()
                .await
            {
                Ok(resp) => {
                    if !resp.status().is_success() {
                        let body = resp.text().await.unwrap_or_default();
                        bail!("sona load_model failed: {}", body);
                    }
                    tracing::debug!("sona model loaded: {}", path);
                    return Ok(());
                }
                Err(e) => {
                    last_err = Some(e);
                }
            }
        }
        Err(last_err.unwrap()).context("failed to send load_model request to sona after 3 attempts")
    }

    pub async fn transcribe_stream(
        &self,
        options: &crate::cmd::TranscribeOptions,
    ) -> Result<impl futures_util::Stream<Item = Result<SonaEvent>>> {
        let url = format!("{}/v1/audio/transcriptions", self.base_url());

        let file = tokio::fs::File::open(&options.path)
            .await
            .context("failed to open audio file")?;
        let file_len = file
            .metadata()
            .await
            .context("failed to read file metadata")?
            .len();

        let file_name = Path::new(&options.path)
            .file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string();

        let stream = ReaderStream::new(file);
        let body = reqwest::Body::wrap_stream(stream);

        let file_part = multipart::Part::stream_with_length(body, file_len)
            .file_name(file_name)
            .mime_str("application/octet-stream")?;

        let mut form = multipart::Form::new().part("file", file_part).text("stream", "true");

        if let Some(ref lang) = options.lang {
            if !lang.is_empty() {
                form = form.text("language", lang.clone());
            }
        }
        if options.translate.unwrap_or(false) {
            form = form.text("translate", "true");
        }
        if let Some(ref p) = options.init_prompt {
            if !p.is_empty() {
                form = form.text("prompt", p.clone());
            }
        }
        if let Some(n) = options.n_threads {
            if n > 0 {
                form = form.text("n_threads", n.to_string());
            }
        }
        if let Some(t) = options.temperature {
            if t > 0.0 {
                form = form.text("temperature", t.to_string());
            }
        }
        if let Some(n) = options.max_text_ctx {
            if n > 0 {
                form = form.text("max_text_ctx", n.to_string());
            }
        }
        if options.word_timestamps.unwrap_or(false) {
            form = form.text("word_timestamps", "true");
        }
        if let Some(n) = options.max_sentence_len {
            if n > 0 {
                form = form.text("max_segment_len", n.to_string());
            }
        }
        if let Some(ref strategy) = options.sampling_strategy {
            if strategy == "beam search" {
                form = form.text("sampling_strategy", "beam_search".to_string());
            }
        }
        if let Some(n) = options.best_of {
            if n > 0 {
                form = form.text("best_of", n.to_string());
            }
        }
        if let Some(n) = options.beam_size {
            if n > 0 {
                form = form.text("beam_size", n.to_string());
            }
        }
        if let Some(ref model) = options.diarize_model {
            if !model.is_empty() {
                form = form.text("diarize_model", model.clone());
            }
        }

        let resp = self
            .client
            .post(&url)
            .multipart(form)
            .send()
            .await
            .context("failed to send transcribe request to sona")?;

        if !resp.status().is_success() {
            let body = resp.text().await.unwrap_or_default();
            bail!("sona transcribe failed: {}", body);
        }

        let stream = resp.bytes_stream().map(move |chunk_result| {
            let chunk = chunk_result.context("error reading sona stream chunk")?;
            // ndjson: each line is a JSON object
            let text = String::from_utf8_lossy(&chunk);
            let mut events = Vec::new();
            for line in text.lines() {
                let line = line.trim();
                if line.is_empty() {
                    continue;
                }
                match serde_json::from_str::<SonaEvent>(line) {
                    Ok(event) => events.push(event),
                    Err(e) => {
                        tracing::warn!("failed to parse sona event: {} (line: {})", e, line);
                    }
                }
            }
            Ok(events)
        });

        // Flatten Vec<SonaEvent> into individual SonaEvent items
        let flat_stream = stream.flat_map(|result: Result<Vec<SonaEvent>>| {
            let items: Vec<Result<SonaEvent>> = match result {
                Ok(events) => events.into_iter().map(Ok).collect(),
                Err(e) => vec![Err(e)],
            };
            futures_util::stream::iter(items)
        });

        Ok(flat_stream)
    }

    pub fn kill(&mut self) {
        tracing::debug!("killing sona process");
        let _ = self.child.kill();
        let _ = self.child.wait();
    }
}

impl Drop for SonaProcess {
    fn drop(&mut self) {
        self.kill();
    }
}
